--------------------------------------
ZZMoove Governor by ZaneZam Changelog:
--------------------------------------

Version 0.1 - first release
---------------------------

- codebase latest smoove governor version from midnight kernel (https://github.com/mialwe/mngb/)
- modified frequency tables to match I9300 standard frequency range 200-1400 mhz
- added cpu hotplug functionality with strictly cpu switching
  (modifications partially taken from ktoonservative governor from
  ktoonsez KT747-JB kernel https://github.com/ktoonsez/KT747-JB)

Version 0.2 - improved
----------------------

- added tuneables to be able to adjust values on early suspend (screen off) via sysfs instead
  of using only hardcoded defaults
- modified hotplug implementation to be able to tune threshold range per core indepentently
  and to be able to manually turn cores offline

  for this functions following new tuneables were indroduced:

  sampling_rate_sleep_multiplier -> sampling rate multiplier on early suspend (possible values 1 or 2, default: 2)
  up_threshold_sleep		 -> up threshold on early suspend (possible range from above 'down_threshold_sleep' up to 100, default: 90)
  down_threshold_sleep		 -> down threshold on early suspend (possible range from 11 to 'under up_threshold_sleep', default: 44)
  smooth_up_sleep		 -> smooth up scaling on early suspend (possible range from 1 to 100, default: 100)
  up_threshold_hotplug1		 -> hotplug threshold for cpu1 (0 disable core1, possible range from 'down_threshold' up to 100, default: 68)
  up_threshold_hotplug2		 -> hotplug threshold for cpu2 (0 disable core2, possible range from 'down_threshold' up to 100, default: 68)
  up_threshold_hotplug3		 -> hotplug threshold for cpu3 (0 disable core3, possible range from 'down_threshold' up to 100, default: 68)
  down_threshold_hotplug1	 -> hotplug threshold for cpu1 (possible range from 1 to under 'up_threshold', default: 55)
  down_threshold_hotplug2	 -> hotplug threshold for cpu2 (possible range from 1 to under 'up_threshold', default: 55)
  down_threshold_hotplug3	 -> hotplug threshold for cpu3 (possible range from 1 to under 'up_threshold', default: 55)

Version 0.3 - more improvements
-------------------------------

- added tuneable 'hotplug_sleep' to be able to turn cores offline only on early suspend (screen off) via sysfs
  possible values: 0 do not touch hotplug-settings on early suspend, values 1, 2 or 3 are equivalent to
  cores which should be online at early suspend
- modified scaling frequency table to match 'overclock' freqencies to max 1600 mhz
- fixed black screen of dead problem in hotplug logic due to missing mutexing on 3-core and 2-core settings
- code cleaning and documentation

Version 0.4 - limits
--------------------

- added 'soft'-freqency-limit. the term 'soft' means here that this is unfortuneately not a hard limit. a hard limit is only possible with
  cpufreq driver which is the freqency 'giver' the governor is only the 'consultant'. So now the governor will scale up to only the given up
  limit on higher system load but if the cpufreq driver 'wants' to go above that limit the freqency will go up there. u can see this for
  example with touchboost or wake up freqencies (1000 and 800 mhz) where the governor obviously will be 'bypassed' by the cpufreq driver.
  but nevertheless this soft-limit will now reduce the use of freqencies higer than given limit and therefore it will reduce power consumption.

  for this function following new tuneables were indroduced:

  freq_limit_sleep		 -> limit freqency at early suspend (possible values 0 disable limit, 200-1600, default: 0)
  freq_limit			 -> limit freqency at awake (possible values 0 disable limit, 200-1600, default: 0)

- added scaling frequencies to frequency tables for a faster up/down scaling. This should bring more performance but on the other hand it
  can be of course a little bit more power consumptive.

  for this function following new tuneables were indroduced:

  fast_scaling			 -> fast scaling at awake (possible values 0 disable or 1 enable, default: 0)
  fast_scaling_sleep (sysfs)	 -> fast scaling at early suspend (possible values 0 disable or 1 enable, default: 0)

- added tuneable 'freq_step_sleep' for setting the freq step at early suspend (possible values same as freq_step 0 to 100, default 5)
- added DEF_FREQ_STEP and IGNORE_NICE macros
- changed downscaling cpufreq relation to the 'lower way'
- code/documentation cleaning

Version 0.5 - performance and fixes
-----------------------------------

- completely reworked fast scaling functionality. now using a 'line jump' logic instead of fixed freq 'colums'.
  fast scaling now in 4 steps and 2 modes possible (mode 1: only fast scaling up and mode2: fast scaling up/down)
- added support for 'Dynamic Screen Frequency Scaling' (original implementation into zzmoove governor highly improved by Yank555)
  originated by AndreiLux more info: http://forum.xda-developers.com/showpost.php?p=38499071&postcount=3
- re-enabled broken conservative sampling down factor functionality ('down skip' method).
  originated by Stratosk - upstream kernel 3.10rc1:
  https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/log/?id=refs%2Ftags%2Fv3.10-rc1&qt=author&q=Stratos+Ka
- changed down threshold check to act like it should.
  originated by Stratosk - upstream kernel 3.10rc1:
  https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/log/?id=refs%2Ftags%2Fv3.10-rc1&qt=author&q=Stratos+Ka
- implemented/ported 'early demand' from ondemand governor.
  originated by Stratosk - more info: http://www.semaphore.gr/80-latests/98-ondemand-early-demand
- implemented/ported 'sampling down momentum' from ondemand governor.
  originated by Stratosk - more info: http://www.semaphore.gr/80-latests/80-sampling-down-momentum
- modified some original conservative code parts regarding frequency scaling which should work better now.
  originated by DerTeufel1980: https://github.com/DerTeufel/android_kernel_samsung_smdk4412/commit/6bab622344c548be853db19adf28c3917896f0a0
- added the possibility to use sampling down momentum or conservative 'down skip' method.
- increased possible max sampling rate sleep multiplier to 4 and sampling down factor to 100000
  accordingly to sampling down momentum implementation.
- added frequency search limit for more efficient frequency searching in scaling 'table' and for improving
  frequency 'hard' and 'soft' limit handling.
- added cpu idle exit time handling like it is in lulzactive
  again work from ktoonsez : https://github.com/ktoonsez/KT747-JB/commit/a5931bee6ea9e69f386a340229745da6f2443b78
  description in lulzactive governor:
  https://github.com/ktoonsez/KT747-JB/blob/a5931bee6ea9e69f386a340229745da6f2443b78/drivers/cpufreq/cpufreq_lulzactive.c
- fixed a little scaling step mistake and added overclocking frequencies up to 1800 mhz in scaling frequency 'tables'.
- fixed possible freezes during start/stop/reload of governor and frequency limit change.
- fixed hotplugging logic at online core 0+3 or 0+2 situations and improved hotplugging in general by
  removing mutex locks and skipping hotplugging when it is not needed.
- added possibility to disable hotplugging (that's a debugging relict but i thought maybe someone will find that usefull so i didn't remove it)
- try to fix lags when coming from suspend if hotplug limitation at sleep was active by enabling all offline cores during resume.
- code cleaning and documentation.

  for this functions following new tuneables were indroduced:

  Early Demand:
  -------------
  early_demand			-> switch to enable/disable early demand functionality (possible values 0 disable or 1 enable, default: 0)
  grad_up_threshold		-> scale up frequency if the load goes up in one step of grad up value (possible range from 1 to 100, default 50)
                                   little example for understanding: when the load rises up in one big 50% step then the
                                   frequency will be scaled up immediately instead of wating till up_threshold is reached.

  Fast Scaling (improved):
  ------------------------
  Fast scaling has now 8 levels which at the same time have 2 modes included. Values from 1-4 equals to scaling jumps in the frequency table
  and uses the Fast Scaling up but normal scaling down mode. Values from 5-8 equals to 1-4 scaling jumps but uses the fast scaling up and fast
  scaling down mode.

  Hotplugging switch:
  -------------------
  disable_hotplug		-> switch to enable/disable hotplugging (possible values are any value above 0 to disable hotplugging and 0 to
                                   enable it, default 0)

  Sampling Down Factor and Sampling Down Momentum:
  ------------------------------------------------
  Description: From the original author of ondemand_sampling_factor David Niemi:
  'This improves performance by reducing the overhead of load evaluation and helping the CPU stay
  at its top speed when truly busy, rather than shifting back and forth in speed.'

  And that 'Sampling Down Momentum' function from stratosk does this dynamicly now! ;)

  sampling_down_max_momentum		-> max sampling down factor which should be set by momentum (0 disable momentum, possible range from
                                           sampling_down_factor up to MAX_SAMPLING_DOWN_FACTOR, default 0 disabled)
  sampling_down_momentum_sensitivity	-> how fast the sampling down factor should be switched (possible values from 1 to 500, default 50)
  sampling_down_factor			-> depending on which mode is active the factor for sampling rate multiplier which influences the whole
                                           sampling rate or the value for stock 'down skip' functionality which influences only the down scaling
                                           mechanism (possible values are from 1 to MAX_SMPLING_DOWN_FACTOR, default 1 disabled)

  Original conservative 'down skip' or 'stock' method can be enabled by setting the momentum tuneable to 0. so if momentum is inactive there will
  be a fallback to the stock method. as the name 'down skip' says this method works 'slightly' different from the ondemand stock sampling down method
  (on which momentum was based on). It just skips the scaling down code for the given samples. if u want to completely disable the sampling down
  functionality u can achieve this by setting sampling down factor to 1. so concluded: setting sampling_down_momentum = 0 and sampling_down_factor = 1
  will disable sampling down completely (that is also the governor default setting)

  Dynamic Screen Frequency Scaling:
  --------------------------------

  Dynamicly switches the screen frequency to 40hz or 60hz depending on cpu scaling and hotplug settings.
  For compiling and enabling this functionality u have to do some more modification to the kernel sources, please take a look at AndreiLux Perseus
  repository and there at following commit: https://github.com/AndreiLux/Perseus-S3/commit/3476799587d93189a091ba1db26a36603ee43519
  After adding this patch u can enable the feature by setting 'CPU_FREQ_LCD_FREQ_DFS=y' in your kernel config and if u want to check if it is
  really working at runtime u can also enable the accounting which AndreiLux added by setting LCD_FREQ_SWITCH_ACCOUNTING=y in the kernel config.
  If all goes well and u have the DFS up and running u can use following tuneables to do some screen magic:
  (thx to Yank555 for highly extend and improving this!)

  lcdfreq_enable		-> to enable/disable LCDFreq scaling (possible values 0 disable or 1 enable, default: 0)
  lcdfreq_kick_in_down_delay	-> the amount of samples to wait below the threshold frequency before entering low display frequency mode (40hz)
  lcdfreq_kick_in_up_delay	-> the amount of samples to wait over the threshold frequency before entering high display frequency mode (60hz)
  lcdfreq_kick_in_freq		-> the frequency threshold - below this cpu frequency the low display frequency will be active
  lcdfreq_kick_in_cores		-> the number of cores which should be online before switching will be active. (also useable in combination
                                   with kickin_freq)

  So this version is a kind of 'featured by' release as i took (again *g*) some ideas and work from other projects and even some of that work
  comes directly from other devs so i wanna thank and give credits:

  First of all to stratosk for his great work 'sampling down momentum' and 'early demand' and for all the code fixes which found their way into
  the upstream kernel version of conservative governor! congrats and props on that stratos, happy to see such a nice and talented dev directly
  contibuting to the upstream kernel, that is a real enrichment for all of us!

  Second to Yank555 for coming up with the idea and improving/completeing (leaves nothing to be desired now *g*) my first
  rudimentary implementation of Dynamic Screen Frequency Scaling from AndreiLux (credits for the idea/work also to him at this point!).

  Third to DerTeufel1980 for his first implementation of stratosk's early demand functionality into version 0.3 of zzmoove governor
  (even though i had to modify the original implementation a 'little bit' to get it working properly ;)) and for some code optimizations/fixes
  regarding scaling.

  Last but not least again to ktoonsez - I 'cherry picked' again some code parts of his ktoonservative governor which should improve this governor
  too.

Version 0.5.1b - bugfixes and more optimisations (in cooperation with Yank555)
------------------------------------------------------------------------------

- highly optimised scaling logic (thx and credits to Yank555)
- simplified some tuneables by using already available stuff instead of using redundant code (thx Yank555)
- reduced/optimised hotplug logic and preperation for automatic detection of available cores
  (maybe this fixes also the scaling/core stuck problems)
- finally fixed the freezing issue on governor stop!

Version 0.6 - flexibility (in cooperation with Yank555)
-------------------------------------------------------

- removed fixed scaling lookup tables and use the system frequency table instead
  changed scaling logic accordingly for this modification (thx and credits to Yank555)
- reduced new hotplug logic loop to a minimum
- again try to fix stuck issues by using seperate hotplug functions out of dbs_check_cpu (credits to ktoonesz)
- added support for 2 and 8 core systems and added automatic detection of cores were it is needed
  (for setting the different core modes you can use the macro 'MAX_CORES'. possible values are: 2,4 or 8, default are 4 cores)
  reduced core threshold defaults to only one up/down default and use an array to hold all threshold values
- fixed some mistakes in 'frequency tuneables' (Yank555):
  stop looping once the frequency has been found
  return invalid error if new frequency is not found in the frequency table

Version 0.6a - scaling logic flexibility (in cooperation with Yank555)
----------------------------------------------------------------------

- added check if CPU freq. table is in ascending or descending order and scale accordingly
  (compatibility for systems with 'inverted' frequency table like it is on OMAP4 platform)
  thanks and credits to Yank555!

Version 0.7 - slow down (in cooperation with Yank555)
-----------------------------------------------------

- reindroduced the 'old way' of hotplugging and scaling in form of the 'Legacy Mode' (macros for enabling/disabling this done by Yank555, thx!)
  NOTE: this mode can only handle 4 cores and a scaling max frequency up to 1800mhz.
- added hotplug idle threshold for a balanced load at CPU idle to reduce possible higher idle temperatures when running on just one core.
       (inspired by JustArchi's observations, thx!)
- added hotplug block cycles to reduce possible hotplugging overhead (credits to ktoonsez)
- added possibility to disable hotplugging only at suspend (inspired by a request of STAticKY, thx for the idea)
- introduced hotplug frequency thresholds (credits to Yank555)
- hotplug tuneables handling optimized (credits to Yank555)
- added version information tuneable (credits to Yank555)

  for this functions following new tuneables were indroduced:

  legacy_mode			-> for switching to the 'old' method of scaling/hotplugging. possible values 0 to disable,
				   any values above 0 to enable (default is 0)
				   NOTE: the legacy mode has to be enabled by uncommenting the macro ENABLE_LEGACY_MODE below!
  hotplug_idle_threshold	-> amount of load under which hotplugging should be disabled at idle times (respectively at scaling minimum).

  hotplug_block_cycles		-> slow down hotplugging by waiting a given amount of cycles before plugging.
				   possible values 0 disbale, any values above 0 (default is 0)
  disable_hotplug_sleep		-> same as disable_hotplug but will only take effect at suspend.
				   possible values 0 disable, any values above 0 to enable (default is 0)
  up_threshold_hotplug_freq1	-> hotplug up frequency threshold for core1.
				   possible values 0 disable and range from over down_threshold_hotplug_freq1 to max scaling freqency (default is 0)
  up_threshold_hotplug_freq2	-> hotplug up frequency threshold for core2.
				   possible values 0 disable and range from over down_threshold_hotplug_freq2 to max scaling freqency (default is 0)
  up_threshold_hotplug_freq3	-> hotplug up frequency threshold for core3.
				   possible values 0 disable and range from over down_threshold_hotplug_freq3 to max scaling freqency (default is 0)
  down_threshold_hotplug_freq1	-> hotplug down frequency threshold for core1.
				   possible values 0 disable and range from min saling to under up_threshold_hotplug_freq1 freqency (default is 0)
  down_threshold_hotplug_freq2	-> hotplug down frequency threshold for core2.
				   possible values 0 disable and range from min saling to under up_threshold_hotplug_freq2 freqency (default is 0)
  down_threshold_hotplug_freq3	-> hotplug down frequency threshold for core3.
				   possible values 0 disable and range from min saling to under up_threshold_hotplug_freq3 freqency (default is 0)
  version			-> show the version of zzmoove governor

Version 0.7a - little fix
-------------------------

- fixed a glitch in hotplug freq threshold tuneables which prevented setting of values in hotplug down freq thresholds when hotplug
  up freq thresholds were set to 0

Version 0.7b - compatibility improved and forgotten things
----------------------------------------------------------

- fixed stuck at max scaling frequency when using stock kernel sources with unmodified cpufreq driver and without any oc capabilities.
- readded forgotten frequency search optimisation in scaling logic (only effective when using governor soft or cpufreq frequency limit)
- readded forgotten minor optimisation in dbs_check_cpu function
- as forgotten to switch in last version Legacy Mode now again disabled by default
- minor code format and comment fixes

Version 0.7c - again compatibility and optimisations
----------------------------------------------------

- frequency search optimisation now fully compatible with ascending ordered system frequency tables (thx to psndna88 for testing!)
- again minor optimisations at multiple points in dbs_check_cpu function
- code cleaning - removed some unnecessary things and whitespaces nuked (sry for the bigger diff but from now on it will be clean ;))
- corrected changelog for previous version regarding limits

Version 0.7d - broken things
----------------------------

- fixed hotplug up threshold tuneables to be able again to disable cores manually via sysfs by setting them to 0
- fixed the problem caused by a 'wrong' tuneable apply order of non sticking values in hotplug down threshold tuneables when
  hotplug up values are lower than down values during apply.
  NOTE: due to this change right after start of the governor the full validation of given values to these tuneables is disabled till
  all the tuneables were set for the first time. so if you set them for example with an init.d script or let them set automatically
  with any tuning app be aware that there are illogical value combinations possible then which might not work properly!
  simply be sure that all up values are higher than the down values and vice versa. after first set full validation checks are enabled
  again and setting of values manually will be checked again.
- fixed a typo in hotplug threshold tuneable macros (would have been only a issue in 8-core mode)
- fixed unwanted disabling of cores when setting hotplug threshold tuneables to lowest or highest possible value
  which would be a load of 100%/1% in up/down_hotplug_threshold and/or scaling frequency min/max in up/down_hotplug_threshold_freq

Version 0.8 - cool down baby!
-----------------------------

- indroduced scaling block cycles (in normal and legacy mode) to reduce unwanted jumps to higher frequencies (how high depends on settings)
  when a load comes up just for a short peroid of time or is hitting the scaling up threshold more often because it is within some higher
  to mid load range. reducing these jumps lowers CPU temperature in general and may also save some juice. so with this function u can influence
  the little bit odd scaling behaving when you are running apps like for example games which are constantly 'holding' system load in
  some range and the freq is scaled up too high for that range. in fact it just looks like so, monitoring apps are mostly too slow to catch load in
  realtime so you are watching almost only 'the past'. so actually it's not really odd it's more like: an app is stressing the system and holding
  it on a higher load level, due to this load level scaling up threshold is more often reached (even if monitoring shows a lower load
  than up_threshold!) the governor scales up very fast (usual zzmoove behaving) and almost never scales down again (even if monitoring shows
  a lower load than down_threshold!). now in patricular these scaling block cycles are throttling up scaling by just skipping it
  for the amount of cycles that you have set up and after that are making a forced scale down in addition for the same amount of cycles. this
  should bring us down to a 'appropriate' frequency when load is hanging around near up threshold.
- indroduced (D)ynamic (S)ampling (R)ate - thx to hellsgod for having the same idea at the same time and pointing me to an example. even though
  at the end i did 'my way' :) DSR switches between two sampling rates depending on the given load threshold from an 'idle' to a 'normal' one.
- added read only tuneable 'sampling_rate_current' for DSR to show current SR and internally use this sampling rate instead of automatically
  changing 'sampling_rate' tuneable in DSR. this keeps things more compatible and avoids problems when governor tuneables are set with tuning
  apps which are saving actual shown values.
- changed setting of sampling rate in governor from 'sampling_rate' to 'sampling_rate_current' and the value at suspend to 'sampling_rate_idle'
  value instead of using current active sampling rate to avoid accidentally setting of 'normal operation' sampling rate in sampling rate idle mode
  which has usually a much lower value
- indroduced build-in profiles in seperate header file (credits to Yank555 for idea and prototype header file)
  you can switch between multible build in profiles by just piping a number into the tuneable 'profile_number'. all tuneable values of the set
  profile will be applied on-the-fly then. if a profile is active and you change any tuneable value from it to a custom one the profile will
  switch to '0' in 'profile_number' and 'custom' in 'profile' for information. with this profiles support developers can simplify their governor
  settings handling by adding all their desired and well proven governor settings into the governor itself instead of having to fiddle around with
  init.d scripts or tuning apps. NOTE: this is just an optional feature, you can still set all tuneables as usual just pay attention that the
  tuneable 'profile_number' is set to '0' then to avoid overwriting values by any build-in profile! for further details about profiles and
  adding own ones check provided 'cpufreq_zzmoove_profiles.h' file.
- added 'profiles_version' tuneable to be able to show seperate profiles header file version
- added enabling of offline cores on governor exit to avoid cores 'stucking' in offline state when switching to a non-hotplug-able governor
  and by the way reduced reduntant code by using an inline function for switching cores on and using the better 'sheduled_work_on-way'
  at all needed places in the code for that purpose
- moved some code parts to legacy mode macro which has only relevance when including the legacy mode in the governor and in addition
  excluded it during runtime if legacy mode is disabled.
- improved freq limit handling in tuneables and in dbs_check_cpu function
- changed value restriction from '11' to '1' in hotplug down threshold and grad up tuneables as this restriction is only nessesary in
  scaling down tuneable
- added missing fast scaling down/normal scaling up mode to fast scaling functionality (value range 9-12 and only available in non-legacy mode
  thx OldBoy.Gr for pointing me to that missing mode!)
- added auto fast scaling aka 'insane' scaling mode to fast scaling functionality - lucky number 13 enables this mode in fast_scaling tuneable
  NOTE: a really funny mode, try it :) but keep in mind setting this in combination with a set freq limit (at sleep or awake)would not make much
  sense as there is not enough frequency range available to jump around then.
- back from the precautious 'mutex_try_lock' to normal 'mutex_lock' in governor 'LIMIT' case -> this should be save again,
  no deadlocks expected any more since hotplug logic has significantly changed in zzmoove version 0.6
- removed also the no longer required and precautious skipping of hotplugging and dbs_check_cpu on multiple places in code and removed
  the mutex locks at governor stop and early suspend/late resume
- added hotlug freq thresholds to legacy scaling mode (same usage as in normal scaling mode)
- seperated hotplug down and up block cycles to be more flexible. this replaces 'hotplug_block_cycles' with 'hotplug_block_up_cycles' tuneable
  and adds one new tunable 'hotplug_block_down_cycles'. functionality is the same as before but u can now differentiate the up and down value.
- added 'early demand sleep' combined with automatic fast scaling (fixed to scaling up mode 2) and if not set already automatic
  (depending on load) switching of sampling rate sleep multiplier to a fixed minimum possible multiplier of 2.
  this should avoid mostly audio or general device connection problems with 'resource hungrier' apps like some music players,
  skype, navigation apps etc. and/or in combination with using bluetooth equipment during screen is off.
  NOTE: this overwrites a possible fast 'scaling_sleep' setting so use either this or 'fast_scaling_sleep'
- added some missing governor tunebable default value definitions
- removed tuneable apply order exception and removed analog value checks in hotplug threshold and hotplug frequency tuneables to avoid
  tuneable values not changing issues. NOTE: keep in mind that all 'down' values should be lower then the analog 'up' values and vice versa!
- removed 200 mhz up hotplugging restriction, so up hotplugging starts at 200 mhz now
- removed some unnecessary macros in scaling logic
- added maximum fast scaling and frequency boost to late resume to react wakeup lags
- merged some improvements from ktoonservativeq governor version for the SGS4 (credits to ktoonsez)
  changes from here: https://github.com/ktoonsez/KT-SGS4/commits/aosp4.4/drivers/cpufreq/cpufreq_ktoonservativeq.c
  Use dedicated high-priority workqueues
  Use NEW high-priority workqueue for hotplugging
  Improved hotplugging in general by reducing calls to plugging functions if they are currently running,
  by reducing calls to external function in up plugging and by changing the down plug loop to an optimized one
- added hotplug boost switch to early demand functionality and up hotplugging function
- added 'hotplug_idle_freq' tuneable to be able to adjust at which frequency idle should begin
- transfered code for frequency table order detection and limit optimisation into a inline function
  and use this function in START,LIMIT case and early suspend/late resume instead of using redundant code
- execute table order detection and freq limit optimization calculations at 'START' and 'LIMIT' case to avoid possible wrong setting of freq
  max after governor start (currently set max frequency value was sometimes not applied) and a wrong soft limit optimization setting
  after undercutting the soft limit with a lower hard limit value
- minor optimisation in hotplug, hotplug block and in all freq search logic parts
- added debugging sysfs interface (can be included/excluded using #define ZZMOOVE_DEBUG) - credits to Yank555!
- added some missing annotation as a prepareation and mainly to avoid some errors when compiling zzmoove in combination with 3.4+ kernel sources
- fixed hotplugging issues when cpufreq limit was set under one or more hotplugging frequency thresholds
  NOTE: now hotplugging frequency thresholds will be completely disabled and a fall back to normal load thresholds will happen
  if the maximal possible frequency will undercut any frequency thresholds
- fixed stopping of up scaling at 100% load when up threshold tuneable is set to the max value of 100
- fixed smooth up not active at 100% load when smooth up tuneable is set to the max value of 100
- fixed many code style and dokumentation issues and made a massive code re-arrangement

  for this functions following new tuneables were indroduced:

  early_demand_sleep		-> same function as early demand on awake but in addition combined with fast scaling and sampling rate
				   switch and only active at sleep. (possible values 0 disable or 1 enable, default is 1)
  grad_up_threshold_sleep	-> 2 way functionality: early demand sleep grad up (load gradient) threshold and at the same time load threshold
				   for switching internally (tuneables are staying at set values!) sampling_rate_sleep_multiplier to 2 and
				   fast_scaling to 2 (possible values from 1 to 100, default is 35)
  hotplug_block_up_cycles	-> (replaces hotplug_block_cycles) slow down up hotplugging by waiting a given amount of cycles before plugging.
				   possible values 0 disbale, any values above 0 (default is 0)
  hotplug_block_down_cycles	-> (replaces hotplug_block_cycles) slow down down hotplugging by waiting a given amount of cycles before plugging.
				   possible values 0 disbale, any values above 0 (default is 0)
  hotplug_idle_freq		-> freq at which the idle should be active (possible values 0 disable and any possible scaling freq, default is 0)
  sampling_rate_current		-> read only and shows currently active sampling rate
  sampling_rate_idle		-> sampling rate which should be used at 'idle times'
				   (possible values are any sampling rate > 'min_sampling_rate', 0 to disable whole function, default is 0)
  sampling_rate_idle_delay	-> delay in cycles for switching from idle to normal sampling rate and vice versa
				   (possible values are any value and 0 to disable delay, default is 0)
  sampling_rate_idle_threshold	-> threshold under which idle sampling rate should be active
				   (possible values 1 to 100, 0 to disable function, default is 0)
  scaling_block_cycles		-> amount of gradients which should be counted (if block threshold is set) and at the same time up scaling should be
				   blocked and after that a forced down scaling should happen (possible values are any value, 0 to disable that
				   function, default is 0)
  scaling_bock_freq		-> frequency at and above the blocking should be active
				   (possible values are any possible scaling freq, 0 to enable blocking permanently at every frequency, default is 0)
  scaling_block_threshold	-> gradient (min value) of load in both directions (up/down) to count-up cycles
				   (possible value are 1 to 100, 0 to disable gradient counting)
  scaling_block_force_down	-> multiplicator for the maximal amount of forced down scaling cycles (force down cycles = block_cycles * force_down)
				   therefore the forced down scaling duration (possible value are 2 to any value, 0 to disable forced down scaling
				   and use only scaling up blocks)
  profile			-> read only and shows name of currently active profile ('none' = no profile, 'custom' = a profile value has changed)
  profile_number		-> switches profile (possible value depends on amount of profiles in cpufreq_zzmoove_profiles.h file,
				   please check this file for futher details!) 0 no profile set = tuneable mode, default 0)
  version_profiles		-> read only and shows version of profile header file

  if ZZMOOVE_DEBUG is defined:
  debug				-> read only and shows various usefull debugging infos

Version 0.9 alpha1 (Yank555.lu)
-------------------------------

- splitted fast_scaling into two separate tunables fast_scaling_up and fast_scaling_down so each can be set individually to 0-4
  (skip 0-4 frequency steps) or 5 to use autoscaling.
- splitted fast_scaling_sleep into two separate tunables fast_scaling_sleep_up and fast_scaling_sleep_down so each can be set individually to 0-4
  (skip 0-4 frequency steps) or 5 to use autoscaling.
- removed legacy mode (necessary to be able to split fast_scaling tunable)
- removed LCD frequency DFS

Version 0.9 alpha2
------------------

- added auto fast scaling step tuneables:
  afs_threshold1 for step one (range from 1 to 100)
  afs_threshold2 for step two (range from 1 to 100)
  afs_threshold3 for step three (range from 1 to 100)
  afs_threshold4 for step four (range from 1 to 100)

Version 0.9 beta1
-----------------

- bump version to beta for public
- added/corrected version informations and removed obsolete ones

Version 0.9 beta2
-----------------

- support for setting a default settings profile at governor start without the need of using the tuneable 'profile_number'
  a default profile can be set with the already available macro 'DEF_PROFILE_NUMBER' check zzmoove_profiles.h for details about
  which profile numbers are possible. this functionality was only half baken in previous versions, now any given profile will be really
  applied when the governor starts. the value '0' (=profile name 'none') in 'DEF_PROFILE_NUMBER' disables this profile hardcoding and
  that's also the default in the source. u still can (with or without enabling a default profile in the macro) as usual use the tuneable
  'profile_number' to switch to a desired profile via sysfs at any later time after governor has started
- added 'blocking' of sysfs in all tuneables during apply of a settings profile to avoid a possible and unwanted overwriting/double
  setting of tuneables mostly in combination with tuning apps where the tuneable apply order isn't influenceable
- added tuneable 'profile_list' for printing out a list of all profiles which are available in the profile header file
- fixed non setting of 'scaling_block_force_down' tuneable when applying profiles
- some documentation added and a little bit of source cleaning

Version 0.9 beta3
-----------------

merged some changes originated by ffolkes (all credits and thx to him)
(source https://github.com/ffolkes/android_kernel_samsung_smdk4412/commits/534ec13388175eb77def021e92b0a44e1e3190d5/drivers/cpufreq/cpufreq_zzmoove.c)

- reordered sysfs attributes
  description by ffolkes: some apps set tuneables by the order in which they are listed in the filesystem. this causes problems when one tuneable
  needs another set first in order to correctly validate. (e.g. you cannot set down_threshold properly until you have first set up_threshold)
- added 'fast down' functionality (based on commits to pegasusq in perseus by andreilux and extended for this version by ZaneZam)
  description by ffolkes: fastdown dynamically applies a (presumably) higher up_threshold and down_threshold after a frequency threshold has been
  reached. the goal is to encourage less time spent on the highest frequencies
- added 'hotplug engage' functionality
  description by ffolkes: when set >0, will not bring any cores online until this frequency is met or exceeded
  goal: reduce unnecessary cores online at low loads
- added 'scaling responsiveness' functioniality
  description by ffolkes: similar to 'frequency for responsiveness' in other governors
  defines a frequency below which we use a different up_threshold to help eliminate lag when starting tasks
- instead of failing when set too high in down_threshold tuneables set the value to the highest it can safely go
- increased possible sampling rate sleep multiplier value to a max of 8 (ZaneZam)
- added missing error handling to some tuneables (ZaneZam)
- fixed non setting of 'hotplug_sleep' tuneable when applying profiles (ZaneZam)
- added up/down threshold to debug tuneable (ZaneZam)
- some code style and comment changes/fixes (ZaneZam)

  for this functions following new tuneables were introduced:

  scaling_fastdown_freq			-> will be enabled once this frequency has been met or exceeded
					   (0 to disable, all possible system frequencies, default is 0)
  scaling_fastdown_up_threshold		-> once the above frequency threshold has been met, this will become the new up_threshold until we fall
					   below the scaling_fastdown_freq again. (range from over fastdown_down_threshold to 100, default is 95)
  scaling_fastdown_down_threshold	-> once the above frequency threshold has been met, this will become the new down_threshold until we fall
					   below the scaling_fastdown_freq again. (range from 11 to under fastdown_up_threshold, default is 90)
  scaling_responsiveness_freq		-> will be enabled once this frequency has been met or exceeded
					   (0 to disable, all possible system frequencies, default is 0)
  scaling_responsiveness_up_threshold	-> the up_threshold that will take effect if scaling_responsiveness_freq is set
					   (range from 11 to 100, default is 30)
  hotplug_engage_freq			-> will not bring any cores online until this frequency is met or exceeded
					   (0 to disable, all possible system frequencies, default is 0)

Version 0.9 beta4
-----------------

- removed 'freq_step' functionality as it never had any function in this governor! it was a left over from mialwes 'smoove' governor and also
  had no function in his governor back then!! so yeah all the 'feelings' about it's influence were placebo! :)
- introduced 'proportional scaling' for more 'connectivity' to current load, this should give more 'balanced' frequencies
  in general. when enabled all targeted frequencies in scaling logic will be compared with the ones from system table method and at the end
  the lowest of them both will be used. so all used scaling frequencies will be 'tentential' lower in both directions
- added support for exynos4 CPU temperature reading (patches available in zzmoove repositories: https://github.com/zanezam)
  this must be enabled via 'CONFIG_EXYNOS4_EXPORT_TEMP=y' in the config of a kernel which has exynos4 CPU temperature export implementation
  included. the default temp polling interval is 1000 ms and can be set with DEF_TMU_READ_DELAY. however the TMU driver has it's own polling
  interval which is 10 seconds, so leaving it at the default value of 1 second is recommended temperature reading will only be enabled if the
  tuneable 'scaling_block_temp' is set and will be disabled whenever early suspend is entered
- if exynos4 CPU temperature reading is enabled in the code use current CPU temperature in scaling block functionality to be able to 'hold' the cpu
  temperatue to the given one in 'scaling_block_temp'. this function is used in combination with the already existent tuneable 'scaling_block_freq'
  so u have to set both to enable it. the possible temperature range is 30°C to 80°C (lower temps are making no sense and higher temps would reach
  into exynos4 TMU driver trottling range)
- if exynos4 CPU temperature reading is enabled added current CPU temperature to debug info tuneable
- added auto adjustment of all available frequency thresholds when scaling max limit has changed
- improved sampling rate idle switching by making it scaling thresholds independent
- again some code style and comment changes/fixes

  for this functions following new tuneables were introduced:

  scaling_proportional			-> if enabled load-proportional frequencies will be calculated in parallel and will be used in decision for
					   next freq step. after a comparison between normal system table step and proportional step the lowest of
					   these two frequencies will be used for next freq step in both directions.
					   (0 to disable, any value above 0 to enable)
  scaling_block_temp			-> CPU temperature threshold from where governors freq 'holding' should start. if the given temperature
  (if CPU temp reading is enabled)	   is reached the frequency used in tuneable 'scaling_block_freq' will be forced targeted and scaling
					   stays on this freq till the temperature is under the threshold again. at the same time hotplugging up
					   work is blocked so in this throttling phase offline cores are staying offline even if the hotplug up
					   thresholds are reached
					   (0 to disable, values between 30 and 80 in °C)
  auto_adjust_freq_thresholds		-> if enabled all freq thresholds used by the governor will be adjusted accordingly to the new scaling
					   max policy. in particular the thresholds will be increased/decreased by the actual changed max freq step
					   if that change will undercut/exceed the actual min/max freq policy it will stop at the max possible
					   frequency step before undercutting/exceeding min/max freq policy
					   (0 to disable, any value above 0 to enable)

Version 1.0 beta1
-----------------

- bump version to 1.0 beta1 because of brought forward plan 'outbreak'
- reworked scaling logic:
  removed unessesary calls of external cpufreq function and use a static variable instead to hold the system freq table during runtime
  fixed frequency stuck on max hard and soft frequency limit (under some circumstances freq was out of scope for the main search loop)
  and added precautions to avoid problems when for what ever reason the freq table is 'messed' or even not available for the governor
  fixed not properly working scaling with descend ordered frequency table like it is for example on snapdragon platform
  added additional propotional scaling mode (mode '1' as usual decide and use the lowest freq, new mode '2' use only propotional
  frequencies like ondemand governor does - switchable as before in 'scaling_proportional' tuneable)
- use static frequency table variable in all frequency checks agains system frequency table in the governor
- fixed 'update_ts_time_stat idle accounting' (kernel patch for kernel version 3.0.x needed, example available in github zzmoove repository)
- fixed non setting of scaling down threshold tuneables under some circumstances (issue on kernel 3.4 when running multible zzmoove instances)
- changed some variable names in scaling range evaluation and debugging tuneable
- added compatibility for kernel version 3.4 (or higher, but only tested on 3.4.0 yet)
- added compatibility for cpufreq implementation used since kernel version 3.10 (NOTE: for backports u can use the macro CPU_IDLE_TIME_IN_CPUFREQ)
- added support for powersuspend (used on some platforms since kernel version 3.4)
- added support for opo specific 'backlight ext control' (kernel patch for opo bacon devices needed, example available in github zzmoove repository)
- added macros to exclude hotplugging functionality (default is disabled=commented for opo devices because of mpdecision
  in general and unmotivated kernel crashes when using it without mpdecision and enabled=uncommended for exynos) in addition disable hopplugging 
  per default if hotplugging code is used to avoid accetential usage of mpdecision and buildin governor hotplugging at the same time

Version 1.0 beta2 (bugfix!)
---------------------------

- avoid kernel crash (usually a oops in smp.c) by checking if a core is online before putting work on it: this problem appeared on opo snapdragon
  platform with proprietary mpdecision hotplugging service. assumption is that there is a delay between initiating hotplugging events from 'userland'
  and gathering core state info in 'kernel land' so under some rare circumestances the governor doesn't 'know about' a changed core state and tries to
  put work on a meanwhile offline core or that hotplug event happend during putting work on a core in the governor

Version 1.0 beta3 (bugfix!)
---------------------------

- changed back canceling of dbs work to syncron instead of asyncron in dbs_timer_exit function to avoid random kernel chrashes (again oops in smp.c)
  when using this governor with the cpufreq implementation of kernel versions 3.10+. problem was initiated by governor restarts during hotplugging
- as an additional precaution check if a core is online before doing critical stuff in dbs_check_cpu main function (might be removeable at a later
  time, more analyses/tests will show)

Version 1.0 beta4 (sync)
------------------------

- removed all previous kernel crash fix attempts and precautions as only the real fix of canceling dbs work syncron introduced in beta3 is needed.
- i9300: use again the conservative governor usual canceling of dbs work syncron instead of asyncron when exiting the governor as this change was
  only needed in combination with older hotplug implementations. as also done in opo version removed again all previously merged kernel crash
  fix attempts and precautions as they were not really needed
- bump version to beta4 to bring opo/i9300 versions in sync again

Version 1.0 beta5
-----------------

- added the possibility to use buildin hotplugging also on snapdragon platform. by defining the maco SNAP_NATIVE_HOTPLUGGING u can enable the
  needed additional changes. Be aware that on snapdragon platform hotplugging from the usual present mpdecision userspace service has to be disabled
  before using native hotplugging in the governor. you can achieve that by switching all cores to forced online mode via sysfs for example by doing
  this: echo "1" >/sys/devices/system/cpu/cpu0/online_control from shell
- fixed internal non-setting of all hotplug down threshold values for hotplugging when switching to any profile settings

Version 1.0 beta6 (feature preview)
-----------------------------------

merged many features up to a working state introduced by ffolkes (all credits and thx to him) which are:

- added native input booster for touch/button/e-pen events (credits to faux123 for original version in intelliactive governor and credits
  to ffolkes for porting it) touch/button events in this version are compatible with note4 and one plus one devices but depending on the used drivers
  they might be compatible with other devices too)
- added core up/down 'staggering' to bring in more control (especially in combination with the next feature) to hotplugging by only enabling/disabling
  one core per cycle
- added separate up/down block multipliers for each core (a more granular addition to the already existent hotplug block cycles)
- added min/max/lock cores functionality to be able to easily setup different 'sticky' hotplug situations
- added up block freq and cycles (similar to scaling fastdown but here for a slowdown of up scaling)
- added snapdragon temperature tripping (adjustable temperature throttling or 'overheating slow down' without any big noticeable side effects)
- some fixes for tools like synapse: keep dynamic tuneables sampling_down_factor and sampling_down_max_mom constant to avoid problems with that tools
  and in addition a little compatibility change for synapse
- added a lot of debugging stuff switchable as usual with the ZZMOOVE_DEBUG macro
- improved profile handling by only switching to the 'custom' profile when a tuneable value has changed
- added the possibility to switch off the profile name change when changing a value of a profile (profile name 'sticky mode')
- added a switchable music mode which has its own prioritised max/min freq settings to be able to react problems when playing music

  Some more details about all the new features can be found on ffolkes plasma kernel project site here: http://www.plasmakernel.com/?p=214
  and in the zzmoove source file history of his github repository here:
  https://github.com/ffolkes/android_kernel_samsung_smdk4412/commits/279c124d6413b51ce7905abbff08600d2670093d/drivers/cpufreq/cpufreq_zzmoove.c

finally also some little changes from my side:

- fixed not respecting mpdecision hotplug settings after resuming from suspend on snapdragon platform if native hotplug is not used.
  this was done by introducing an additional mode in disable_hotplug and disable_hotplug_sleep tuneables (value 2). when using this mode the
  forced online switching of cores when changing suspend/resume state is disabled then
- renamed/extended hotplug switching function for new hotplug features

  NOTE:
  this version is kind of work in progress but all features are working so far (i think *g*), so plz consider it as a feature preview version
  most of this new features are disabled by default and some not yet available in any settings profile so if u want to try such out u have to
  enable/adjust them by using the corresponding sysfs tuneables. all features will be fully integrated/documented and if needed fixed in next version

Version 1.0 beta6a
------------------

- replaced dirty backlight-hook by proper lcd notifier callback, so it should run on any
  msm8974 based platform now (as long as the lcd_notifier change is implemented)

  credits to Lord Boeffla

Version 1.0 beta7 (sync)
------------------------

- fixed multiple macro issues and also added some missing ones in new functionalities
- fixed non-setting of hotplug core limit tunables when using profiles
- fixed using a wrong tuneable var for inputboost_cycles when using profiles
- fixed setting of scaling proportional tunable when using profiles
- fixed sometimes not respecting freq soft limit if current freq was above that limit during setup
- fixed not working hotplugging after restoring from thermal tripping events on snapdragon platform
- fixed code style issues and removed some unnecessary code parts
- probably fixed crashes when using powersave implementation caused by multiple registering (not confirmed yet)
- moved all hotplugging work and hotplugging cycle counters to core 0
- register input booster and initialize some 'one time stuff' only once on core 0
- merged some minor improvements from kernel upstream version of conservative governor
- added missing freq thresholds to auto adjustment functionality
- added the possibility to disable power management set by kernel config but still use the lcd notifier
- added music min cores functionality to support setup min cores when enabling music state
- added music min freq limit handling to freq search optimization for ascending ordered system freq tables
- added music and inputboost tuneables to profile tuneable
- added missing profile name switching to music* tunebales (except music state, as this one is independent and not included in any profile)
- added missing snapdragon temperature value and governor instances info to debugging tuneable
- instead of one static flag use an array with sepearted flags for hotplug freq out of range functionality
- made main freq search function inline
- changed load calculation to be more compatible with asyncron multicore SoC's and added exynos4 detection macro for compatibility
- indroduced adaptation of all freq thresholds in the governor:
  this means you can enter now any freq value in all freq tuneables and the governor will try to adapt it to the current system frequency table
  if the values are in range of the current policy min/max it will use the next valid freq, if not it will use the min or max possible frequency
  this works also with all available profiles, so the frequencies in the profiles will also be adapted if they are used with another frequnecy
  table than the one the profiles were based on
- try to avoid a rare crash after coming from suspend when using input boost functionality in combination with restart loop:
  unfortunately this is still not stable so atm. it is not recommended to use the restart loop functionality! therefore it is disabled per default
  via macro in this version and will be enabled again if there is a stable solution available!
- renamed tt_triptemp tuneable to 'scaling_trip_temp', reordered it and added it to profiles tuneable
- renamed all snapdragon SoC related macros to a more meaningful naming
- added/updated some documentation and removed redundant parts
- take this version sync as a opportunity to finally outsource/merge the massive changelog to a separate main changelog file for both 
  versions (i9300 and OPO)

Version 1.0 beta7a (bugfix)
---------------------------

- fixed some half-baken macro and miss-placed code issues
- fixed open comment after removing changelog from source file in opo-bacon version
- added missing variable definitions for freq adjustment functionality in i9300 version
- renamed 'debug' tuneable to 'zzmoove_debug' to be more unique

Version 1.0 beta8
-----------------

- again fixed some (hopefully last!) half-baken macros to avoid compile errors with some macro setting combinations
  (some of them fixed by others like legolas93, thx for that!)
- fixed not using normal scaling and permanently falling back to proportional scaling in descending ordered frequency table mode
- changed inputboost de-registering when governor stops (maybe fixes freeze/reboot issues on some devices)
- reworked/corrected all kernel source compatibility macros (sucessfully tested on kernel version 3.0, 3.4 and 3.16)
- allow usage of lcd notifier alone and powersuspend simultaneous (thx to DespairFactor!)
- changed proportional frequency calculation to the new improved version without deadband effect (credits to stratosk!)
  more info: http://www.phoronix.com/scan.php?page=news_item&px=MTc0NzA
  NOTE: this new calculation almost prevents the usage of policy->min frequency (because load must be 0 to get policy->min) on systems
  with 'nervious' idle load behaving. if u want to use new proportional scaling for example on mobile devices i would suggest
  to use the new proportional scaling mode '3' which has been introduced to be able to reduce rarely usage of policy->min frequencies 
  on lower load due to that new calculation. this is a compromise (because of missing CPUFREQ_RELATION_C in kernel sources < v3.17)
  and is done by using the deadband frequency range of old proportional frequency calculation to bring frequency down again to policy->min 
  in that range. so with mode '3' it behaves almost the same as with old calculation. to conclude: in the tuneable 'scaling_proportional' u can 
  now switch to Mode '1' = mixed mode = compare normal with prop freq and use the lower one, Mode '2' = use only prop freq with new calculation 
  like it is in newer ondemand governor versions and Mode '3' = same as Mode '2' but with policy->min freq fix on lower load
- set inputboost freq default value to 0 to be independent of the used platform frequency table
- added the possibility to completely disable profiles support, auto frequency adjustment and music limits
  by defining new macros ENABLE_PROFILES_SUPPORT, ENABLE_AUTO_ADJUST_FREQ and ENABLE_MUSIC_LIMITS
- added some missing profile switching protections to some new tuneables indroduced in previous versions
- tagged all #endifs with the corresponding macro as a comment to reduce dizziness when dealing with them
- added missing hotplug multiplier tuneables
- added the possibility to setup 6 core mode via MAX_CORES macro
- added some debug info in scaling logic an added loaded profile information to debugging tuneable
- some code cleanup and documentation
